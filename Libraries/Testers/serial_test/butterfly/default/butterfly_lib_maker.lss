
butterfly_lib_maker.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000176  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000040  00000000  00000000  000001ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 00000061  00000000  00000000  0000020a  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   0000013f  00000000  00000000  0000026b  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 000000f2  00000000  00000000  000003aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000267  00000000  00000000  0000049c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000060  00000000  00000000  00000704  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    000000d3  00000000  00000000  00000764  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000007c  00000000  00000000  00000837  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2e 00 	jmp	0x5c	; 0x5c <__ctors_end>
   4:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
   8:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
   c:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  10:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  14:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  18:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  1c:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  20:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  24:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  28:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  2c:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  30:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  34:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  38:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  3c:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  40:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  44:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  48:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  4c:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  50:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  54:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>
  58:	0c 94 38 00 	jmp	0x70	; 0x70 <__bad_interrupt>

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	d4 e0       	ldi	r29, 0x04	; 4
  64:	de bf       	out	0x3e, r29	; 62
  66:	cd bf       	out	0x3d, r28	; 61
  68:	0e 94 3a 00 	call	0x74	; 0x74 <main>
  6c:	0c 94 b9 00 	jmp	0x172	; 0x172 <_exit>

00000070 <__bad_interrupt>:
  70:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000074 <main>:
int main()
{
	// Do nothing - creates object modules
}
  74:	80 e0       	ldi	r24, 0x00	; 0
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	08 95       	ret

0000007a <OSCCAL_calibration>:
{
    unsigned char calibrate = 0;//FALSE;
    int temp;
    unsigned char tempL;

    CLKPR = (1<<CLKPCE);        /// set Clock Prescaler Change Enable
  7a:	80 e8       	ldi	r24, 0x80	; 128
  7c:	80 93 61 00 	sts	0x0061, r24
    /// set prescaler = 8, Inter RC 8Mhz / 8 = 1Mhz
    CLKPR = (1<<CLKPS1) | (1<<CLKPS0);
  80:	83 e0       	ldi	r24, 0x03	; 3
  82:	80 93 61 00 	sts	0x0061, r24
    
    TIMSK2 = 0;             ///disable OCIE2A and TOIE2
  86:	10 92 70 00 	sts	0x0070, r1

    ASSR = (1<<AS2);        ///select asynchronous operation of timer2 (32,768kHz)
  8a:	88 e0       	ldi	r24, 0x08	; 8
  8c:	80 93 b6 00 	sts	0x00B6, r24
    
    OCR2A = 200;            /// set timer2 compare value 
  90:	88 ec       	ldi	r24, 0xC8	; 200
  92:	80 93 b3 00 	sts	0x00B3, r24

    TIMSK0 = 0;             /// delete any interrupt sources
  96:	10 92 6e 00 	sts	0x006E, r1
        
    TCCR1B = (1<<CS10);     /// start timer1 with no prescaling
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	80 93 81 00 	sts	0x0081, r24
    TCCR2A = (1<<CS20);     /// start timer2 with no prescaling
  a0:	80 93 b0 00 	sts	0x00B0, r24

    while((ASSR & 0x01) | (ASSR & 0x04));       ///wait for TCN2UB and TCR2UB to be cleared
  a4:	20 91 b6 00 	lds	r18, 0x00B6
  a8:	80 91 b6 00 	lds	r24, 0x00B6
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	84 70       	andi	r24, 0x04	; 4
  b0:	90 70       	andi	r25, 0x00	; 0
  b2:	30 e0       	ldi	r19, 0x00	; 0
  b4:	21 70       	andi	r18, 0x01	; 1
  b6:	30 70       	andi	r19, 0x00	; 0
  b8:	82 2b       	or	r24, r18
  ba:	93 2b       	or	r25, r19
  bc:	89 2b       	or	r24, r25
  be:	91 f7       	brne	.-28     	; 0xa4 <OSCCAL_calibration+0x2a>
    
    while(!calibrate)
    {
        cli(); /// mt __disable_interrupt();  // disable global interrupt
        
        TIFR1 = 0xFF;   /// delete TIFR1 flags
  c0:	4f ef       	ldi	r20, 0xFF	; 255
    
        if (temp > 6250)
        {
            OSCCAL--;   /// the internRC oscillator runs to fast, decrease the OSCCAL
        }
        else if (temp < 6120)
  c2:	51 e0       	ldi	r21, 0x01	; 1

    Delay(1000);    /// wait for external crystal to stabilise
    
    while(!calibrate)
    {
        cli(); /// mt __disable_interrupt();  // disable global interrupt
  c4:	f8 94       	cli
        
        TIFR1 = 0xFF;   /// delete TIFR1 flags
  c6:	46 bb       	out	0x16, r20	; 22
        TIFR2 = 0xFF;   /// delete TIFR2 flags
  c8:	47 bb       	out	0x17, r20	; 23
        
        TCNT1H = 0;     /// clear timer1 counter
  ca:	10 92 85 00 	sts	0x0085, r1
        TCNT1L = 0;
  ce:	10 92 84 00 	sts	0x0084, r1
        TCNT2 = 0;      /// clear timer2 counter
  d2:	10 92 b2 00 	sts	0x00B2, r1
           
	while ( !(TIFR2 & (1<<OCF2A)) ); // while ( !(TIFR2 && (1<<OCF2A)) );   // wait for timer2 compareflag
  d6:	b9 9b       	sbis	0x17, 1	; 23
  d8:	fe cf       	rjmp	.-4      	; 0xd6 <OSCCAL_calibration+0x5c>
    
        TCCR1B = 0; /// stop timer1
  da:	10 92 81 00 	sts	0x0081, r1

        sei(); /// __enable_interrupt();  // enable global interrupt
  de:	78 94       	sei
    
        if ( (TIFR1 & (1<<TOV1)) ) // if ( (TIFR1 && (1<<TOV1)) )
  e0:	b0 99       	sbic	0x16, 0	; 22
  e2:	17 c0       	rjmp	.+46     	; 0x112 <OSCCAL_calibration+0x98>
        {
            temp = 0xFFFF;      /// if timer1 overflows, set the temp to 0xFFFF
        }
        else
        {   /// read out the timer1 counter value
            tempL = TCNT1L;
  e4:	90 91 84 00 	lds	r25, 0x0084
            temp = TCNT1H;
  e8:	80 91 85 00 	lds	r24, 0x0085
            temp = (temp << 8);
  ec:	38 2f       	mov	r19, r24
  ee:	20 e0       	ldi	r18, 0x00	; 0
            temp += tempL;
  f0:	b9 01       	movw	r22, r18
  f2:	69 0f       	add	r22, r25
  f4:	71 1d       	adc	r23, r1
  f6:	cb 01       	movw	r24, r22
        }
    
        if (temp > 6250)
  f8:	78 e1       	ldi	r23, 0x18	; 24
  fa:	8b 36       	cpi	r24, 0x6B	; 107
  fc:	97 07       	cpc	r25, r23
  fe:	24 f0       	brlt	.+8      	; 0x108 <OSCCAL_calibration+0x8e>
        {
            OSCCAL--;   /// the internRC oscillator runs to fast, decrease the OSCCAL
 100:	80 91 66 00 	lds	r24, 0x0066
 104:	81 50       	subi	r24, 0x01	; 1
 106:	08 c0       	rjmp	.+16     	; 0x118 <OSCCAL_calibration+0x9e>
        }
        else if (temp < 6120)
 108:	88 5e       	subi	r24, 0xE8	; 232
 10a:	97 41       	sbci	r25, 0x17	; 23
 10c:	14 f0       	brlt	.+4      	; 0x112 <OSCCAL_calibration+0x98>
 10e:	81 e0       	ldi	r24, 0x01	; 1
 110:	06 c0       	rjmp	.+12     	; 0x11e <OSCCAL_calibration+0xa4>
        {
            OSCCAL++;   /// the internRC oscillator runs to slow, increase the OSCCAL
 112:	80 91 66 00 	lds	r24, 0x0066
 116:	8f 5f       	subi	r24, 0xFF	; 255
 118:	80 93 66 00 	sts	0x0066, r24
 11c:	80 e0       	ldi	r24, 0x00	; 0
        }
        else
            calibrate = 1;///TRUE;   // the interRC is correct
    
        TCCR1B = (1<<CS10); /// start timer1
 11e:	50 93 81 00 	sts	0x0081, r21

    while((ASSR & 0x01) | (ASSR & 0x04));       ///wait for TCN2UB and TCR2UB to be cleared

    Delay(1000);    /// wait for external crystal to stabilise
    
    while(!calibrate)
 122:	88 23       	and	r24, r24
 124:	79 f2       	breq	.-98     	; 0xc4 <OSCCAL_calibration+0x4a>
        else
            calibrate = 1;///TRUE;   // the interRC is correct
    
        TCCR1B = (1<<CS10); /// start timer1
    }
}
 126:	08 95       	ret

00000128 <butterfly_init>:
*/
/************************************************************/
void butterfly_init(void)
{

    OSCCAL_calibration();   /// Calibrate the OSCCAL byte
 128:	0e 94 3d 00 	call	0x7a	; 0x7a <OSCCAL_calibration>

    ACSR = (1<<ACD);
 12c:	20 e8       	ldi	r18, 0x80	; 128
 12e:	20 bf       	out	0x30, r18	; 48

    /// Disable Digital input on PF0-2 (power save)
    DIDR1 = (7<<ADC0D);
 130:	87 e0       	ldi	r24, 0x07	; 7
 132:	80 93 7f 00 	sts	0x007F, r24

    PORTB = 0xFF;       /// Enable pullups on Ports B and E
 136:	8f ef       	ldi	r24, 0xFF	; 255
 138:	85 b9       	out	0x05, r24	; 5
    PORTE = 0xFF;
 13a:	8e b9       	out	0x0e, r24	; 14
    
    /// boost IntRC to 2Mhz to achieve 19200 baudrate
    CLKPR = (1<<CLKPCE);        /// set Clock Prescaler Change Enable
 13c:	e1 e6       	ldi	r30, 0x61	; 97
 13e:	f0 e0       	ldi	r31, 0x00	; 0
 140:	20 83       	st	Z, r18
    /// set prescaler = 4, Inter RC 8Mhz / 4 = 2Mhz
    CLKPR = (1<<CLKPS1);    
 142:	92 e0       	ldi	r25, 0x02	; 2
 144:	90 83       	st	Z, r25

    UBRRH = 0;
 146:	10 92 c5 00 	sts	0x00C5, r1
    UBRRL = 12;
 14a:	8c e0       	ldi	r24, 0x0C	; 12
 14c:	80 93 c4 00 	sts	0x00C4, r24

    /// Enable 2x speed
    UCSRA = (1<<U2X);
 150:	90 93 c0 00 	sts	0x00C0, r25

    /// Enable receiver and transmitter
	// JWP added | 10/22/10
    UCSRB |= (1<<RXEN)|(1<<TXEN)|(0<<RXCIE)|(0<<UDRIE);
 154:	e1 ec       	ldi	r30, 0xC1	; 193
 156:	f0 e0       	ldi	r31, 0x00	; 0
 158:	80 81       	ld	r24, Z
 15a:	88 61       	ori	r24, 0x18	; 24
 15c:	80 83       	st	Z, r24

    /// Async. mode, 8N1
    UCSRC = (0<<UMSEL)|(0<<UPM0)|(0<<USBS)|(3<<UCSZ0)|(0<<UCPOL);
 15e:	86 e0       	ldi	r24, 0x06	; 6
 160:	80 93 c2 00 	sts	0x00C2, r24

// TODO 10/23/10
//    sei(); /// mt __enable_interrupt();
    
    /// mt PCMSK1 = (1<<PORTB6) | (1<<PORTB4);
	PCMSK1 = (1<<PINB6) | (1<<PINB4);       // set pin-change interrupt mask
 164:	80 e5       	ldi	r24, 0x50	; 80
 166:	80 93 6c 00 	sts	0x006C, r24
  	EIFR   = (1<<PCIF1);                    // clear external intterupt flag 1
 16a:	2c bb       	out	0x1c, r18	; 28
	EIMSK  = (1<<PCIE1);   
 16c:	2d bb       	out	0x1d, r18	; 29

}
 16e:	08 95       	ret

00000170 <Delay>:
{
    unsigned char i; // mt int i;
    
    while (millisec--)
        for (i=0; i<125; i++);
}
 170:	08 95       	ret

00000172 <_exit>:
 172:	f8 94       	cli

00000174 <__stop_program>:
 174:	ff cf       	rjmp	.-2      	; 0x174 <__stop_program>
